using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using KafkaClient.Common;
using KafkaClient.Connections;
using KafkaClient.Protocol;
using KafkaClient.Testing;
using NUnit.Framework;

namespace KafkaClient.Tests.Unit
{
    [TestFixture]
    public class SocketTransportTests : TransportTests<SocketTransport>
    {
        [Test]
        public void CreatingWithSslConfigurationThrowsException()
        {
            var config = new ConnectionConfiguration(sslConfiguration: new SslConfiguration());
            try {
                using (new SocketTransport(TestConfig.ServerEndpoint(), config, TestConfig.Log)) { }
                Assert.Fail("Should have thrown ArgumentOutOfRangeException");
            } catch (ArgumentOutOfRangeException) {
                // expected
            }
        }

        protected override SocketTransport CreateTransport(Endpoint endpoint, IConnectionConfiguration configuration, ILog log)
        {
            return new SocketTransport(endpoint, configuration, log);
        }
    }

    [TestFixture]
    public class SslTransportTests : TransportTests<SslTransport>
    {
        private const string CertPassword = "password";
        private static readonly byte[] CertRawBytes = { 0x30, 0x82, 0xA, 0x47, 0x2, 0x1, 0x3, 0x30, 0x82, 0xA, 0x7, 0x6, 0x9, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0xD, 0x1, 0x7, 0x1, 0xA0, 0x82, 0x9, 0xF8, 0x4, 0x82, 0x9, 0xF4, 0x30, 0x82, 0x9, 0xF0, 0x30, 0x82, 0x6, 0xC, 0x6, 0x9, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0xD, 0x1, 0x7, 0x1, 0xA0, 0x82, 0x5, 0xFD, 0x4, 0x82, 0x5, 0xF9, 0x30, 0x82, 0x5, 0xF5, 0x30, 0x82, 0x5, 0xF1, 0x6, 0xB, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0xD, 0x1, 0xC, 0xA, 0x1, 0x2, 0xA0, 0x82, 0x4, 0xFE, 0x30, 0x82, 0x4, 0xFA, 0x30, 0x1C, 0x6, 0xA, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0xD, 0x1, 0xC, 0x1, 0x3, 0x30, 0xE, 0x4, 0x8, 0x29, 0x6A, 0xA1, 0xCD, 0x65, 0x91, 0xCB, 0xD8, 0x2, 0x2, 0x7, 0xD0, 0x4, 0x82, 0x4, 0xD8, 0xCF, 0x0, 0x17, 0x2C, 0x3, 0x38, 0x5D, 0x91, 0x63, 0xCA, 0xC7, 0x27, 0x67, 0x1D, 0x38, 0xEF, 0xE9, 0xCC, 0x74, 0xD1, 0xD7, 0x67, 0xE0, 0xE2, 0x56, 0xE, 0xB, 0x6E, 0xC2, 0xB2, 0x3C, 0xE1, 0x76, 0xCC, 0x47, 0x2B, 0xC9, 0xE5, 0x59, 0xE8, 0x25, 0xFA, 0x2B, 0x4B, 0x9, 0xEF, 0xC5, 0x7E, 0xE9, 0x6D, 0x44, 0xD0, 0x74, 0xE3, 0xA9, 0x0, 0xD8, 0xBE, 0xB1, 0x57, 0xBB, 0x6E, 0xDF, 0x17, 0x49, 0x52, 0x9D, 0xAE, 0x1F, 0x46, 0x35, 0xB4, 0x60, 0xDB, 0xAF, 0x96, 0x57, 0x5E, 0xDC, 0xBF, 0x3E, 0xA0, 0xA9, 0x74, 0x15, 0x46, 0x98, 0x5D, 0xA4, 0x1A, 0x45, 0xC9, 0x4A, 0x78, 0x35, 0x71, 0x93, 0xA6, 0x87, 0xE3, 0x53, 0x15, 0xDD, 0xEB, 0xF, 0xD2, 0xF, 0xFC, 0xDF, 0xF1, 0x13, 0x4F, 0x80, 0x5A, 0x6B, 0xCD, 0xFD, 0x8, 0x20, 0xB0, 0x65, 0x35, 0xE3, 0xE4, 0xBC, 0xFC, 0xBC, 0x83, 0xC8, 0xA4, 0x2C, 0xD2, 0xFD, 0x28, 0x22, 0x3F, 0xBF, 0x41, 0xB2, 0xFE, 0xF8, 0x1B, 0x68, 0xF3, 0x46, 0xA8, 0xC4, 0xFF, 0xEA, 0x7E, 0xBD, 0xE5, 0xD3, 0xC3, 0x82, 0xB7, 0x20, 0x62, 0xB0, 0x82, 0xE8, 0x3B, 0xF3, 0x77, 0x27, 0xC5, 0xC3, 0xA8, 0x13, 0x29, 0x99, 0xD3, 0x93, 0x18, 0x8A, 0x57, 0x22, 0x95, 0xF, 0x76, 0x20, 0xF, 0x9D, 0xF1, 0x83, 0x2D, 0x31, 0x3D, 0x55, 0xA3, 0x70, 0x9C, 0x17, 0xA2, 0x65, 0x3E, 0x45, 0x62, 0x3E, 0x3D, 0x82, 0x33, 0xF9, 0x4B, 0x6B, 0x21, 0xE2, 0xFE, 0xE2, 0x75, 0x5, 0x9A, 0x61, 0x62, 0x95, 0x7A, 0xB8, 0x94, 0x32, 0x9C, 0xBC, 0x69, 0x2D, 0x8A, 0xCC, 0x57, 0xD4, 0x47, 0xBB, 0x21, 0xF6, 0x41, 0x68, 0xD6, 0x44, 0x43, 0xCE, 0xB0, 0xC2, 0x19, 0x65, 0xF7, 0xE1, 0x23, 0x43, 0x97, 0x52, 0xB, 0x85, 0x0, 0xD4, 0xF, 0xC5, 0x9, 0x59, 0xAD, 0x44, 0x9B, 0xF5, 0x46, 0x11, 0xE9, 0x98, 0x3D, 0x6, 0xD2, 0xF1, 0x9, 0x73, 0x6B, 0xD3, 0x4E, 0x9C, 0x4C, 0x4E, 0x50, 0x50, 0x6B, 0x46, 0xF, 0x82, 0xEA, 0x7D, 0x30, 0x25, 0xC6, 0x3B, 0xFF, 0x5C, 0x29, 0x5C, 0x8, 0xCD, 0xD5, 0x43, 0xE9, 0x73, 0x66, 0x5F, 0xB2, 0xE4, 0xEE, 0x66, 0xED, 0xEE, 0x31, 0xE4, 0xCB, 0xC6, 0xD2, 0xE5, 0x56, 0x4F, 0xDA, 0x11, 0x4A, 0x69, 0x49, 0x35, 0x5C, 0xC4, 0xDB, 0x42, 0xD3, 0xDC, 0x21, 0x51, 0x12, 0xEE, 0x9A, 0xE6, 0xA, 0x77, 0x6C, 0x70, 0x14, 0x7, 0x4A, 0x4F, 0x49, 0x1D, 0x3F, 0x42, 0x34, 0x2F, 0xAF, 0x9C, 0x31, 0xF7, 0xF3, 0xCA, 0x14, 0x5, 0x1D, 0xC0, 0x85, 0x42, 0x8A, 0x55, 0x12, 0xD9, 0x9E, 0x7A, 0x17, 0xEC, 0x1A, 0x2, 0xF, 0x74, 0x91, 0x3, 0xD, 0xEA, 0x4B, 0xF9, 0xB4, 0x95, 0x33, 0x14, 0xCB, 0x41, 0xDB, 0xA1, 0x2B, 0xAC, 0xD, 0xDC, 0x37, 0x4A, 0xFC, 0x61, 0x68, 0xFF, 0x7A, 0x34, 0x76, 0xF1, 0xF6, 0x86, 0x3C, 0x2B, 0xB6, 0x6C, 0xCD, 0xD4, 0xB2, 0xED, 0x61, 0x65, 0x6E, 0x1B, 0x96, 0xE9, 0xE6, 0xC8, 0x2A, 0xE7, 0xC4, 0x99, 0xC9, 0xC2, 0x57, 0xB2, 0xEC, 0x8A, 0x94, 0x97, 0xE3, 0x68, 0x21, 0x95, 0x5F, 0x92, 0x59, 0x55, 0x21, 0xDE, 0x79, 0xEC, 0x22, 0x53, 0x15, 0x10, 0xA4, 0x10, 0xF0, 0x3C, 0x63, 0x5D, 0x8F, 0x55, 0xE4, 0xE8, 0x88, 0xC, 0x7E, 0x67, 0x4A, 0xC0, 0xBA, 0xA6, 0x50, 0x7E, 0xE6, 0xAC, 0xAD, 0x70, 0x9C, 0x1B, 0x8B, 0xEE, 0xBC, 0xB4, 0x84, 0x3D, 0x79, 0xA4, 0xD3, 0x15, 0xCD, 0xA, 0x26, 0xAE, 0xBD, 0x2A, 0x29, 0xCB, 0x2C, 0xD1, 0xC0, 0xB, 0x9, 0x16, 0xEF, 0x16, 0xEC, 0x70, 0x29, 0xA3, 0x6, 0x7D, 0x9C, 0x2E, 0x9D, 0x81, 0x6E, 0xAB, 0x33, 0x6D, 0xBB, 0x6E, 0x33, 0xD2, 0x2F, 0x2B, 0xC9, 0xC5, 0x6A, 0x88, 0x9B, 0x2A, 0x31, 0x4, 0x6, 0x23, 0x61, 0x64, 0x9A, 0x65, 0x3E, 0x2, 0x5E, 0x36, 0xAE, 0xE7, 0x96, 0x7D, 0x89, 0xE2, 0x17, 0xC1, 0x72, 0x95, 0xD9, 0x63, 0xF2, 0x74, 0x6, 0x6F, 0x5D, 0x2F, 0x62, 0xA4, 0x8D, 0x66, 0x78, 0xDD, 0x81, 0x5B, 0x2F, 0x39, 0xAA, 0x63, 0xB7, 0x27, 0xA4, 0xC7, 0xC6, 0xAA, 0x1E, 0x69, 0xB6, 0xE6, 0xA6, 0xE2, 0xDC, 0x3E, 0xF4, 0xDF, 0x80, 0x87, 0xDE, 0x78, 0x48, 0xD0, 0x66, 0x0, 0x99, 0x0, 0xFE, 0x83, 0x93, 0x32, 0x27, 0xF5, 0xB1, 0xA1, 0x30, 0x20, 0x42, 0x98, 0xA4, 0xE0, 0xD0, 0x67, 0xD2, 0x54, 0x1, 0x6E, 0x48, 0xEF, 0xD6, 0x15, 0x32, 0x45, 0xAA, 0x49, 0x62, 0x22, 0x1C, 0x8C, 0x1D, 0x82, 0xE9, 0x7B, 0xC, 0x47, 0xA8, 0xF5, 0x4, 0x7, 0x36, 0x93, 0x8B, 0xB3, 0x34, 0xED, 0x3B, 0x54, 0x12, 0x59, 0x6C, 0x45, 0xB2, 0xDD, 0x49, 0x9E, 0xBD, 0x24, 0x54, 0xC2, 0xBC, 0xBB, 0xF7, 0x98, 0xE0, 0x14, 0xF3, 0xD9, 0x61, 0x1F, 0x7E, 0x4B, 0x63, 0x98, 0x50, 0xC5, 0xE5, 0xF9, 0x68, 0xBA, 0xC7, 0x6, 0x1E, 0x77, 0x55, 0x22, 0xAE, 0xF3, 0x9C, 0xCD, 0xCE, 0x5C, 0xC0, 0xB3, 0xC9, 0x78, 0xCD, 0x33, 0xB6, 0x83, 0x5C, 0x50, 0xC6, 0xEB, 0x4A, 0xF8, 0x8, 0x5E, 0x16, 0x64, 0x88, 0x8A, 0x14, 0x7F, 0x82, 0x38, 0xDC, 0x68, 0x6B, 0x0, 0x82, 0x9C, 0x49, 0xC4, 0xDE, 0xAD, 0x3B, 0x6, 0x2C, 0x23, 0x8D, 0x7B, 0x67, 0x6F, 0xF5, 0x38, 0x7A, 0x4, 0x2B, 0x49, 0xE9, 0x4C, 0x97, 0x39, 0x72, 0xD5, 0x99, 0x84, 0xFF, 0x2E, 0x2A, 0xE8, 0x2E, 0xAE, 0x44, 0x8B, 0xD7, 0x52, 0xFE, 0x6C, 0x8, 0x2B, 0x8, 0x11, 0xD9, 0xC1, 0x2F, 0xEA, 0xFE, 0x54, 0x96, 0xAD, 0xD9, 0x62, 0x20, 0x6D, 0x46, 0x42, 0x8F, 0xF3, 0xD4, 0x98, 0xA1, 0x99, 0xB3, 0x3B, 0x8A, 0x46, 0xFB, 0xF2, 0x2F, 0xA5, 0xF7, 0xAE, 0x10, 0x20, 0xE4, 0x59, 0x54, 0xBF, 0x9F, 0x69, 0xF8, 0x64, 0xD8, 0xEE, 0x46, 0x82, 0xD2, 0x1F, 0xE3, 0x79, 0xC5, 0x9F, 0x70, 0x22, 0xF5, 0x5B, 0xC1, 0x38, 0xA7, 0xC9, 0xBE, 0xBF, 0x23, 0x80, 0xBE, 0x91, 0xFD, 0xD4, 0x2, 0xE6, 0x39, 0x5F, 0x23, 0x8E, 0x20, 0xB8, 0x9F, 0x6F, 0xEF, 0xF0, 0x8A, 0xBA, 0x12, 0x1B, 0xEB, 0xC2, 0x53, 0xC0, 0xCB, 0x4, 0x46, 0x5E, 0x80, 0x9E, 0x16, 0x54, 0xA5, 0xE9, 0x31, 0x50, 0x71, 0x5D, 0xCE, 0x9B, 0xFB, 0xAE, 0x83, 0x90, 0x7E, 0x28, 0xC, 0xA7, 0x13, 0x7A, 0xA4, 0xAD, 0xF1, 0xF, 0x6D, 0x3C, 0xFC, 0x0, 0xC9, 0xEA, 0xD0, 0x90, 0xEF, 0x8A, 0x1D, 0x18, 0x5D, 0xB2, 0x3D, 0xEE, 0x9A, 0xF4, 0xF9, 0x2, 0xF6, 0xD5, 0xD0, 0xCE, 0x5C, 0x6, 0xF6, 0x1D, 0x28, 0x4E, 0x14, 0xB7, 0x36, 0x6D, 0xDA, 0xD3, 0x63, 0xC1, 0xD3, 0x42, 0x72, 0x11, 0x5C, 0x5E, 0x9F, 0x92, 0x2C, 0xF9, 0x22, 0x95, 0xA7, 0x5D, 0xD0, 0x35, 0xD4, 0x1C, 0x61, 0x75, 0xC9, 0x28, 0x24, 0x2F, 0x5E, 0x5, 0xF3, 0x38, 0xF5, 0xA4, 0x42, 0x11, 0xC0, 0x22, 0x3E, 0xA0, 0x70, 0x17, 0xA, 0x1F, 0x1A, 0xA, 0xA1, 0x85, 0x67, 0x71, 0x93, 0xBF, 0x75, 0x23, 0xEC, 0xCB, 0xFD, 0xE2, 0xBA, 0x26, 0x88, 0x22, 0x85, 0x85, 0xBD, 0x47, 0xCC, 0x8F, 0x43, 0xF8, 0x2C, 0xC7, 0x2D, 0xD1, 0xDE, 0xC7, 0xB0, 0xC3, 0x88, 0x6B, 0x84, 0x64, 0x57, 0x9, 0xF7, 0x3C, 0xAA, 0xD6, 0x8, 0xB7, 0x44, 0xC5, 0x8, 0x58, 0xEA, 0xDE, 0xFC, 0x7E, 0x47, 0xFC, 0xC5, 0x4B, 0x82, 0x82, 0x8F, 0x77, 0x58, 0xCA, 0x92, 0x43, 0xAE, 0xD8, 0x63, 0x12, 0x7A, 0x1C, 0x7B, 0xC2, 0x69, 0x20, 0xD4, 0xAD, 0x70, 0xFA, 0x38, 0x7F, 0xDF, 0xB6, 0xE1, 0x6E, 0x76, 0x13, 0x60, 0xDA, 0xC6, 0x6F, 0xA6, 0x80, 0x71, 0x6F, 0x7C, 0x6D, 0x81, 0x10, 0x3B, 0x78, 0xDD, 0x21, 0x82, 0xFD, 0x3D, 0x7F, 0x9, 0x64, 0xA1, 0x3, 0x59, 0x0, 0x5B, 0x1, 0x72, 0xEB, 0xC3, 0x75, 0xF3, 0xC2, 0xBB, 0xE3, 0x67, 0x55, 0x21, 0x6F, 0xD4, 0x63, 0x4C, 0xEE, 0xF4, 0x68, 0xC, 0xC6, 0xEF, 0xD6, 0x34, 0x68, 0x7D, 0xBB, 0x65, 0xAA, 0x3A, 0x68, 0x62, 0x52, 0xB8, 0x17, 0xCD, 0x79, 0x9E, 0x76, 0x13, 0x9E, 0xA2, 0xB7, 0xC6, 0xA0, 0x28, 0xDB, 0xF3, 0xE7, 0x8B, 0xB6, 0xC0, 0x70, 0x6B, 0xF3, 0xFC, 0xBE, 0x6E, 0x4, 0xC8, 0x52, 0xF, 0x72, 0x61, 0x6C, 0x7D, 0xA7, 0xD5, 0x9E, 0x31, 0xAB, 0xA9, 0x45, 0xD0, 0x9F, 0xE1, 0x3D, 0x2C, 0x8B, 0x1A, 0x49, 0xE3, 0x5A, 0x5E, 0x61, 0xEB, 0xFE, 0x30, 0x13, 0xB2, 0xFC, 0xF1, 0x9D, 0x6D, 0xDB, 0x2, 0x71, 0x9E, 0x47, 0x80, 0x1, 0xB3, 0xEA, 0x1F, 0xBA, 0x3, 0x5E, 0xEB, 0x21, 0x3F, 0xE, 0xC1, 0x72, 0x92, 0x1D, 0x9D, 0xBD, 0xAD, 0x97, 0x97, 0xAF, 0x37, 0xCB, 0x96, 0x9D, 0xF5, 0x55, 0xFB, 0x4F, 0x3C, 0xCF, 0x98, 0xBE, 0xE9, 0x4F, 0xF0, 0x33, 0x1C, 0x10, 0xCB, 0x18, 0xC7, 0xCA, 0x15, 0x6B, 0x55, 0x49, 0xA6, 0x3D, 0xDB, 0x2, 0x6A, 0x22, 0x2, 0x19, 0x40, 0xCD, 0xD8, 0x14, 0xAB, 0x47, 0x6B, 0x4C, 0x88, 0x2, 0x7F, 0x63, 0x7C, 0xE5, 0xCD, 0x78, 0x3B, 0xAB, 0x7E, 0x19, 0xAF, 0x31, 0x81, 0xDF, 0x30, 0x13, 0x6, 0x9, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0xD, 0x1, 0x9, 0x15, 0x31, 0x6, 0x4, 0x4, 0x1, 0x0, 0x0, 0x0, 0x30, 0x5B, 0x6, 0x9, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0xD, 0x1, 0x9, 0x14, 0x31, 0x4E, 0x1E, 0x4C, 0x0, 0x7B, 0x0, 0x43, 0x0, 0x42, 0x0, 0x45, 0x0, 0x42, 0x0, 0x37, 0x0, 0x35, 0x0, 0x46, 0x0, 0x33, 0x0, 0x2D, 0x0, 0x36, 0x0, 0x32, 0x0, 0x31, 0x0, 0x31, 0x0, 0x2D, 0x0, 0x34, 0x0, 0x46, 0x0, 0x39, 0x0, 0x44, 0x0, 0x2D, 0x0, 0x41, 0x0, 0x33, 0x0, 0x30, 0x0, 0x45, 0x0, 0x2D, 0x0, 0x31, 0x0, 0x39, 0x0, 0x35, 0x0, 0x45, 0x0, 0x46, 0x0, 0x46, 0x0, 0x43, 0x0, 0x42, 0x0, 0x30, 0x0, 0x39, 0x0, 0x46, 0x0, 0x45, 0x0, 0x7D, 0x30, 0x6B, 0x6, 0x9, 0x2B, 0x6, 0x1, 0x4, 0x1, 0x82, 0x37, 0x11, 0x1, 0x31, 0x5E, 0x1E, 0x5C, 0x0, 0x4D, 0x0, 0x69, 0x0, 0x63, 0x0, 0x72, 0x0, 0x6F, 0x0, 0x73, 0x0, 0x6F, 0x0, 0x66, 0x0, 0x74, 0x0, 0x20, 0x0, 0x45, 0x0, 0x6E, 0x0, 0x68, 0x0, 0x61, 0x0, 0x6E, 0x0, 0x63, 0x0, 0x65, 0x0, 0x64, 0x0, 0x20, 0x0, 0x43, 0x0, 0x72, 0x0, 0x79, 0x0, 0x70, 0x0, 0x74, 0x0, 0x6F, 0x0, 0x67, 0x0, 0x72, 0x0, 0x61, 0x0, 0x70, 0x0, 0x68, 0x0, 0x69, 0x0, 0x63, 0x0, 0x20, 0x0, 0x50, 0x0, 0x72, 0x0, 0x6F, 0x0, 0x76, 0x0, 0x69, 0x0, 0x64, 0x0, 0x65, 0x0, 0x72, 0x0, 0x20, 0x0, 0x76, 0x0, 0x31, 0x0, 0x2E, 0x0, 0x30, 0x30, 0x82, 0x3, 0xDC, 0x6, 0x9, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0xD, 0x1, 0x7, 0x1, 0xA0, 0x82, 0x3, 0xCD, 0x4, 0x82, 0x3, 0xC9, 0x30, 0x82, 0x3, 0xC5, 0x30, 0x82, 0x3, 0xC1, 0x6, 0xB, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0xD, 0x1, 0xC, 0xA, 0x1, 0x3, 0xA0, 0x82, 0x3, 0x99, 0x30, 0x82, 0x3, 0x95, 0x6, 0xA, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0xD, 0x1, 0x9, 0x16, 0x1, 0xA0, 0x82, 0x3, 0x85, 0x4, 0x82, 0x3, 0x81, 0x30, 0x82, 0x3, 0x7D, 0x30, 0x82, 0x2, 0x65, 0xA0, 0x3, 0x2, 0x1, 0x2, 0x2, 0x9, 0x0, 0xD9, 0x3F, 0x74, 0xFA, 0x3E, 0x8A, 0x76, 0xF8, 0x30, 0xD, 0x6, 0x9, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0xD, 0x1, 0x1, 0xB, 0x5, 0x0, 0x30, 0x55, 0x31, 0xB, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x43, 0x41, 0x31, 0x10, 0x30, 0xE, 0x6, 0x3, 0x55, 0x4, 0x8, 0xC, 0x7, 0x4F, 0x6E, 0x74, 0x61, 0x72, 0x69, 0x6F, 0x31, 0x10, 0x30, 0xE, 0x6, 0x3, 0x55, 0x4, 0x7, 0xC, 0x7, 0x54, 0x6F, 0x72, 0x6F, 0x6E, 0x74, 0x6F, 0x31, 0x14, 0x30, 0x12, 0x6, 0x3, 0x55, 0x4, 0xA, 0xC, 0xB, 0x4B, 0x61, 0x66, 0x6B, 0x61, 0x43, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x31, 0xC, 0x30, 0xA, 0x6, 0x3, 0x55, 0x4, 0x3, 0xC, 0x3, 0x61, 0x77, 0x72, 0x30, 0x1E, 0x17, 0xD, 0x31, 0x37, 0x30, 0x32, 0x30, 0x32, 0x30, 0x35, 0x34, 0x32, 0x32, 0x30, 0x5A, 0x17, 0xD, 0x32, 0x37, 0x30, 0x31, 0x33, 0x31, 0x30, 0x35, 0x34, 0x32, 0x32, 0x30, 0x5A, 0x30, 0x55, 0x31, 0xB, 0x30, 0x9, 0x6, 0x3, 0x55, 0x4, 0x6, 0x13, 0x2, 0x43, 0x41, 0x31, 0x10, 0x30, 0xE, 0x6, 0x3, 0x55, 0x4, 0x8, 0xC, 0x7, 0x4F, 0x6E, 0x74, 0x61, 0x72, 0x69, 0x6F, 0x31, 0x10, 0x30, 0xE, 0x6, 0x3, 0x55, 0x4, 0x7, 0xC, 0x7, 0x54, 0x6F, 0x72, 0x6F, 0x6E, 0x74, 0x6F, 0x31, 0x14, 0x30, 0x12, 0x6, 0x3, 0x55, 0x4, 0xA, 0xC, 0xB, 0x4B, 0x61, 0x66, 0x6B, 0x61, 0x43, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x31, 0xC, 0x30, 0xA, 0x6, 0x3, 0x55, 0x4, 0x3, 0xC, 0x3, 0x61, 0x77, 0x72, 0x30, 0x82, 0x1, 0x22, 0x30, 0xD, 0x6, 0x9, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0xD, 0x1, 0x1, 0x1, 0x5, 0x0, 0x3, 0x82, 0x1, 0xF, 0x0, 0x30, 0x82, 0x1, 0xA, 0x2, 0x82, 0x1, 0x1, 0x0, 0xA6, 0xF7, 0x4E, 0x35, 0xC4, 0xB6, 0xA6, 0xFC, 0x4C, 0x7F, 0xB8, 0x8F, 0x78, 0x98, 0x17, 0xB, 0xF, 0xE8, 0xBD, 0x8, 0xAE, 0x6, 0x7E, 0x71, 0x69, 0xEB, 0x98, 0xAE, 0xF1, 0x2C, 0x38, 0x9C, 0xB7, 0xC0, 0xD, 0x63, 0x2F, 0x59, 0x27, 0xFF, 0x56, 0xB2, 0xCA, 0x96, 0x5B, 0x54, 0xD6, 0xE, 0x93, 0xF6, 0xF2, 0x94, 0xFF, 0x7, 0x56, 0x9C, 0x80, 0x74, 0x88, 0xAC, 0xB4, 0x51, 0xD8, 0x2D, 0x5, 0x7A, 0xB8, 0xC7, 0xB6, 0x27, 0xF, 0xC4, 0xD9, 0x72, 0x1E, 0x68, 0x3C, 0xE0, 0x8D, 0x3C, 0xCA, 0x8A, 0x95, 0x37, 0x21, 0x5F, 0x5B, 0xB5, 0xEA, 0x1F, 0xE8, 0x20, 0xA0, 0x7C, 0xB3, 0x32, 0x0, 0xE2, 0xB8, 0x7C, 0x42, 0x38, 0x96, 0xD9, 0x96, 0x83, 0x69, 0x76, 0xE4, 0x52, 0xFA, 0x5F, 0xAB, 0xD3, 0xC1, 0x44, 0x16, 0x89, 0x97, 0x2F, 0x39, 0xA5, 0xE6, 0x6A, 0xA8, 0xBA, 0x6E, 0x14, 0x22, 0xC8, 0x64, 0x41, 0x36, 0x18, 0x1E, 0xC6, 0x22, 0x78, 0xE2, 0x5C, 0xD9, 0xE, 0xBC, 0x95, 0x51, 0xD1, 0x71, 0xB9, 0x1C, 0x7C, 0x62, 0x1F, 0x60, 0x57, 0x98, 0x4F, 0x23, 0xD7, 0xEE, 0xCD, 0xA0, 0xA2, 0x5E, 0x11, 0x5B, 0xAD, 0x32, 0x64, 0xA, 0x8D, 0x81, 0xF8, 0x81, 0xA8, 0x30, 0x53, 0x74, 0xA8, 0x57, 0x22, 0xBF, 0xE6, 0x42, 0xFC, 0x89, 0xC1, 0xD7, 0x62, 0xE, 0x5F, 0xA7, 0x81, 0x2A, 0x3A, 0xAE, 0xFE, 0xE2, 0xD0, 0x54, 0x8, 0x90, 0x9F, 0xB0, 0xC7, 0x1F, 0x56, 0xB8, 0x86, 0xFC, 0x5C, 0xF8, 0x32, 0x8E, 0x30, 0xFA, 0xA0, 0x32, 0x35, 0xAB, 0x62, 0x1D, 0xB6, 0x77, 0xBF, 0xC6, 0x54, 0x1B, 0x12, 0x51, 0x22, 0xB5, 0x51, 0x53, 0xCC, 0x99, 0xF6, 0x2F, 0x81, 0x14, 0xA5, 0xD5, 0xCB, 0x14, 0x1F, 0x9F, 0x17, 0xEE, 0xB6, 0xCD, 0x98, 0x41, 0x10, 0x4E, 0xD, 0x9A, 0xF9, 0x2, 0x3, 0x1, 0x0, 0x1, 0xA3, 0x50, 0x30, 0x4E, 0x30, 0x1D, 0x6, 0x3, 0x55, 0x1D, 0xE, 0x4, 0x16, 0x4, 0x14, 0xD8, 0x86, 0x62, 0x94, 0x1D, 0x7F, 0x60, 0x41, 0x94, 0x7D, 0xE8, 0xC8, 0x67, 0x64, 0x80, 0xAF, 0xB5, 0x1E, 0xE4, 0x91, 0x30, 0x1F, 0x6, 0x3, 0x55, 0x1D, 0x23, 0x4, 0x18, 0x30, 0x16, 0x80, 0x14, 0xD8, 0x86, 0x62, 0x94, 0x1D, 0x7F, 0x60, 0x41, 0x94, 0x7D, 0xE8, 0xC8, 0x67, 0x64, 0x80, 0xAF, 0xB5, 0x1E, 0xE4, 0x91, 0x30, 0xC, 0x6, 0x3, 0x55, 0x1D, 0x13, 0x4, 0x5, 0x30, 0x3, 0x1, 0x1, 0xFF, 0x30, 0xD, 0x6, 0x9, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0xD, 0x1, 0x1, 0xB, 0x5, 0x0, 0x3, 0x82, 0x1, 0x1, 0x0, 0x42, 0x3E, 0x45, 0xDD, 0xAA, 0x21, 0x36, 0x6F, 0x67, 0x24, 0x77, 0xCC, 0xD3, 0xDD, 0x0, 0x57, 0x39, 0x7A, 0xBA, 0x68, 0x33, 0x16, 0x1A, 0x51, 0x7C, 0x9D, 0x59, 0x81, 0x51, 0xD8, 0x66, 0x9, 0x50, 0xEC, 0xA6, 0x77, 0xF8, 0x37, 0xD, 0xC1, 0x73, 0x4D, 0x7C, 0x7F, 0x4B, 0xDD, 0x5C, 0x4B, 0x16, 0x66, 0x75, 0x71, 0xA8, 0xD8, 0xB8, 0xE5, 0x4, 0x35, 0xC6, 0x88, 0x2E, 0x42, 0x72, 0x40, 0x96, 0x32, 0x5C, 0x64, 0x45, 0x9B, 0xDC, 0x54, 0xCA, 0x30, 0x18, 0x92, 0xB, 0x16, 0xC8, 0xE, 0xAA, 0xCD, 0x6B, 0x6C, 0xA8, 0xA4, 0xE0, 0x63, 0x21, 0x73, 0xF6, 0x22, 0x15, 0xD, 0x56, 0x42, 0x4E, 0xB7, 0x6A, 0x76, 0x1C, 0xAB, 0xBA, 0xF0, 0xE0, 0xD6, 0x7F, 0x15, 0xED, 0xAB, 0x5D, 0xF8, 0x26, 0xAA, 0x77, 0x3, 0xCB, 0xAB, 0x21, 0x98, 0xD3, 0xFA, 0x87, 0x9B, 0x44, 0x67, 0xB9, 0xB, 0xD, 0xDD, 0x3C, 0xD, 0xC6, 0x45, 0x50, 0xA0, 0xD1, 0x36, 0x8A, 0xE1, 0x3, 0x8E, 0x2F, 0xD2, 0xE5, 0x9E, 0xF2, 0xC4, 0xBC, 0x7E, 0x1F, 0x13, 0x5A, 0x38, 0xB8, 0x12, 0xBB, 0x4F, 0xFA, 0x59, 0x82, 0xFB, 0xC2, 0x69, 0xA8, 0x21, 0xA8, 0x2E, 0x7E, 0x44, 0x8C, 0x88, 0x3D, 0x59, 0x16, 0x5E, 0xC8, 0xEF, 0x8F, 0x89, 0x5B, 0xF2, 0x50, 0x7F, 0x9, 0x90, 0xB2, 0x43, 0x73, 0xA5, 0x4B, 0xC2, 0x87, 0x8A, 0x18, 0xE1, 0x46, 0xA0, 0x16, 0x80, 0x61, 0x93, 0xF6, 0x18, 0xA1, 0xD5, 0x27, 0xFA, 0x78, 0x70, 0x5F, 0x40, 0xB4, 0xBF, 0x88, 0x87, 0xE, 0x5B, 0x8C, 0xEF, 0xEB, 0x19, 0x2B, 0xD2, 0x2D, 0x56, 0xA7, 0x1, 0x6A, 0x64, 0xBD, 0xD2, 0x9B, 0xF6, 0x2B, 0xB9, 0x67, 0x6F, 0x53, 0xD3, 0xA5, 0xB8, 0x90, 0xB0, 0x2, 0xD4, 0x31, 0xB9, 0x39, 0x8, 0x69, 0xCD, 0xB3, 0xE8, 0xEA, 0x54, 0x31, 0x15, 0x30, 0x13, 0x6, 0x9, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0xD, 0x1, 0x9, 0x15, 0x31, 0x6, 0x4, 0x4, 0x1, 0x0, 0x0, 0x0, 0x30, 0x37, 0x30, 0x1F, 0x30, 0x7, 0x6, 0x5, 0x2B, 0xE, 0x3, 0x2, 0x1A, 0x4, 0x14, 0x54, 0x60, 0xDE, 0xC, 0x8C, 0x88, 0xC1, 0x8A, 0x62, 0x4A, 0x5A, 0xD6, 0x5F, 0x6B, 0x31, 0x1C, 0x18, 0x14, 0xF1, 0x69, 0x4, 0x14, 0x11, 0x6, 0x61, 0x9, 0xC, 0x79, 0x2D, 0x97, 0xEF, 0xA5, 0x0, 0x6F, 0x69, 0x5F, 0xDD, 0xAA, 0x52, 0x30, 0x94, 0xE0 };
        private readonly X509Certificate _certificate = new X509Certificate2(CertRawBytes, CertPassword);

        [Test]
        public void CreatingSslTransportWithoutSslConfigurationThrowsException()
        {
            var config = new ConnectionConfiguration(sslConfiguration: null);
            try {
                using (new SslTransport(TestConfig.ServerEndpoint(), config, TestConfig.Log)) { }
                Assert.Fail("Should have thrown ArgumentOutOfRangeException");
            } catch (ArgumentOutOfRangeException) {
                // expected
            }
        }

        [Test]
        //[Ignore("Only for creating the certificate bytes from the file")]
        public void CreateCertificate()
        {
            var path = @"C:\Code\KafkaClient\src\KafkaClient.Tests\localhost.pfx";
            var cert = new X509Certificate2();
            cert.Import(path, CertPassword, X509KeyStorageFlags.Exportable);
            
            var buffer = new StringBuilder("private static readonly byte[] CertRawBytes = { ");
            foreach (var b in cert.Export(X509ContentType.Pfx, CertPassword))
            {
                buffer.AppendFormat("0x{0:X}, ", b);
            }
            buffer.Remove(buffer.Length - 2, 2);
            buffer.Append(" };");

            Console.WriteLine(buffer.ToString());
        }

        protected override SslTransport CreateTransport(Endpoint endpoint, IConnectionConfiguration configuration, ILog log)
        {
            var configWithSsl = new ConnectionConfiguration(configuration.ConnectionRetry,
                configuration.VersionSupport,
                configuration.RequestTimeout,
                configuration.ReadBufferSize,
                configuration.WriteBufferSize,
                configuration.IsTcpKeepalive,
                configuration.Encoders.Values,
                new SslConfiguration((sender, certificate, chain, errors) => (errors & SslPolicyErrors.RemoteCertificateNotAvailable) == 0, localCollection: new X509CertificateCollection(new []{ _certificate })),
                configuration.OnDisconnected,
                configuration.OnConnecting,
                configuration.OnConnected);
            return new SslTransport(endpoint, configWithSsl, log);
        }

        protected override TcpServer CreateServer(int port, ILog log)
        {
            return new TcpServer(port, log, _certificate);
        }
    }

    public abstract class TransportTests<T> where T : class, ITransport
    {
        protected abstract T CreateTransport(Endpoint endpoint, IConnectionConfiguration configuration, ILog log);

        protected virtual TcpServer CreateServer(int port, ILog log) => new TcpServer(port, log);

        #region Connect

        [Test]
        public async Task ShouldAttemptMultipleTimesWhenConnectionFails()
        {
            var count = 0;
            var config = new ConnectionConfiguration(onConnecting: (e, a, _) => Interlocked.Increment(ref count));
            using (var transport = CreateTransport(TestConfig.ServerEndpoint(), config, TestConfig.Log)) {
                var task = transport.ConnectAsync(CancellationToken.None);
                await TaskTest.WaitFor(() => count > 1, 10000);
                Assert.That(count, Is.GreaterThan(1));
            }
        }

        #endregion

        #region Dispose

        [Test]
        public async Task ShouldDisposeWithoutExceptionThrown()
        {
            var endpoint = TestConfig.ServerEndpoint();
            using (var server = CreateServer(endpoint.Ip.Port, TestConfig.Log))
            {
                var transport = CreateTransport(endpoint, TestConfig.Options.ConnectionConfiguration, TestConfig.Log);
                server.OnConnected = () => transport.Dispose();
                await Task.WhenAny(transport.ConnectAsync(CancellationToken.None), Task.Delay(TimeSpan.FromSeconds(3)));
                transport.Dispose();
            }
        }

        [Test]
        public async Task ShouldDisposeEvenWhilePollingToReconnect()
        {
            var connectionAttempt = -1;
            var config = new ConnectionConfiguration(Retry.AtMost(5), onConnecting: (e, a, _) => connectionAttempt = a);
            var endpoint = TestConfig.ServerEndpoint();
            using (var transport = CreateTransport(endpoint, config, TestConfig.Log)) {
                var taskResult = transport.ConnectAsync(CancellationToken.None);

                await TaskTest.WaitFor(() => connectionAttempt >= 0);

                transport.Dispose();
                await Task.WhenAny(taskResult, Task.Delay(1000)).ConfigureAwait(false);

                Assert.That(taskResult.IsFaulted, Is.True);
                Assert.That(taskResult.Exception.InnerException, Is.TypeOf<ObjectDisposedException>());
            }
        }

        [Test]
        public async Task ShouldDisposeEvenWhileAwaitingReadAndThrowException()
        {
            int readSize = 0;
            var config = new ConnectionConfiguration(onReading: (e, size) => readSize = size);
            var endpoint = TestConfig.ServerEndpoint();
            using (CreateServer(endpoint.Ip.Port, TestConfig.Log)) {
                var transport = CreateTransport(endpoint, config, TestConfig.Log);
                try {
                    await transport.ConnectAsync(CancellationToken.None);
                    var buffer = new byte[4];
                    var taskResult = transport.ReadBytesAsync(buffer, 4, _ => { }, CancellationToken.None);

                    await TaskTest.WaitFor(() => readSize > 0);

                    using (transport) { }
                    transport = null;

                    await taskResult.CancelAfter();
                    Assert.Fail("Expected ObjectDisposedException to be thrown");
                } catch (ObjectDisposedException) {
                    // expected
                } finally {
                    transport?.Dispose();
                }
            }
        }

        #endregion

        #region ReadBytes

        [Test]
        public async Task ReadShouldBlockUntilAllBytesRequestedAreReceived()
        {
            var readCompleted = 0;
            var bytesReceived = 0;
            var config = new ConnectionConfiguration(
                onReadBytes: (e, attempted, actual, elapsed) => Interlocked.Add(ref bytesReceived, actual),
                onRead: (e, read, elapsed) => Interlocked.Increment(ref readCompleted));
            var endpoint = TestConfig.ServerEndpoint();
            using (var server = CreateServer(endpoint.Ip.Port, TestConfig.Log)) {
                using (var transport = CreateTransport(endpoint, config, TestConfig.Log)) {
                    await transport.ConnectAsync(CancellationToken.None);
                    var buffer = new byte[4];
                    var readTask = transport.ReadBytesAsync(buffer, 4, _ => { }, CancellationToken.None);

                    // Sending first 3 bytes...
                    await Task.WhenAny(server.ClientConnected, Task.Delay(TimeSpan.FromSeconds(3)));
                    await server.SendDataAsync(new ArraySegment<byte>(new byte[] { 0, 0, 0 }));

                    // Ensuring task blocks...
                    await TaskTest.WaitFor(() => bytesReceived > 0);
                    Assert.That(readTask.IsCompleted, Is.False, "Task should still be running, blocking.");
                    Assert.That(readCompleted, Is.EqualTo(0), "Should still block even though bytes have been received.");
                    Assert.That(bytesReceived, Is.EqualTo(3), "Three bytes should have been received and we are waiting on the last byte.");

                    // Sending last byte...
                    var sendLastByte = await server.SendDataAsync(new ArraySegment<byte>(new byte[] { 0 }));
                    Assert.That(sendLastByte, Is.True, "Last byte should have sent.");

                    // Ensuring task unblocks...
                    await TaskTest.WaitFor(() => readTask.IsCompleted);
                    Assert.That(bytesReceived, Is.EqualTo(4), "Should have received 4 bytes.");
                    Assert.That(readTask.IsCompleted, Is.True, "Task should have completed.");
                    Assert.That(readCompleted, Is.EqualTo(1), "Task ContinueWith should have executed.");
                }
            }
        }

        [Test]
        public async Task ReadShouldBeAbleToReceiveMoreThanOnce()
        {
            var endpoint = TestConfig.ServerEndpoint();
            using (var server = CreateServer(endpoint.Ip.Port, TestConfig.Log)) {
                using (var transport = CreateTransport(endpoint, TestConfig.Options.ConnectionConfiguration, TestConfig.Log)) {
                    const int firstMessage = 99;
                    const string secondMessage = "testmessage";

                    // Sending first message to receive...
                    var send = server.SendDataAsync(new ArraySegment<byte>(firstMessage.ToBytes()));

                    await transport.ConnectAsync(CancellationToken.None);
                    var buffer = new byte[48];
                    await transport.ReadBytesAsync(buffer, 4, _ => { }, CancellationToken.None);
                    Assert.That(buffer.ToInt32(), Is.EqualTo(firstMessage));

                    // Sending second message to receive...
                    var send2 = (Task) server.SendDataAsync(new ArraySegment<byte>(Encoding.ASCII.GetBytes(secondMessage)));
                    var result = new MemoryStream();
                    await transport.ReadBytesAsync(buffer, secondMessage.Length, _ => { result.Write(buffer, 0, _); }, CancellationToken.None);
                    Assert.That(Encoding.ASCII.GetString(result.ToArray(), 0, (int)result.Position), Is.EqualTo(secondMessage));
                }
            }
        }

        [Test]
        public async Task ReadShouldBeAbleToReceiveMoreThanOnceAsyncronously()
        {
            var endpoint = TestConfig.ServerEndpoint();
            using (var server = CreateServer(endpoint.Ip.Port, TestConfig.Log)) {
                using (var transport = CreateTransport(endpoint, TestConfig.Options.ConnectionConfiguration, TestConfig.Log)) {
                    const int firstMessage = 99;
                    const int secondMessage = 100;

                    await transport.ConnectAsync(CancellationToken.None);

                    // Sending first message to receive..."
                    var send1 = server.SendDataAsync(new ArraySegment<byte>(firstMessage.ToBytes()));
                    var buffer1 = new byte[4];
                    var firstResponseTask = transport.ReadBytesAsync(buffer1, 4, _ => { }, CancellationToken.None);

                    // Sending second message to receive...
                    var send2 = server.SendDataAsync(new ArraySegment<byte>(secondMessage.ToBytes()));
                    var buffer2 = new byte[4];
                    var secondResponseTask = transport.ReadBytesAsync(buffer2, 4, _ => { }, CancellationToken.None);

                    await Task.WhenAll(firstResponseTask, secondResponseTask);
                    Assert.That(buffer1.ToInt32(), Is.EqualTo(firstMessage));
                    Assert.That(buffer2.ToInt32(), Is.EqualTo(secondMessage));
                }
            }
        }

        [Test]
        public async Task ReadShouldNotLoseDataFromStreamOverMultipleReads()
        {
            var endpoint = TestConfig.ServerEndpoint();
            using (var server = CreateServer(endpoint.Ip.Port, TestConfig.Log)) {
                using (var transport = CreateTransport(endpoint, TestConfig.Options.ConnectionConfiguration, TestConfig.Log)) {
                    const int firstMessage = 99;
                    const string secondMessage = "testmessage";
                    var bytes = Encoding.UTF8.GetBytes(secondMessage);

                    var payload = new KafkaWriter()
                        .Write(firstMessage);

                    //send the combined payload
                    var send = server.SendDataAsync(payload.ToSegment(false));

                    await transport.ConnectAsync(CancellationToken.None);
                    var buffer = new byte[48];
                    var read = await transport.ReadBytesAsync(buffer, 4, _ => { }, CancellationToken.None);
                    await send;
                    Assert.That(read, Is.EqualTo(4));
                    Assert.That(buffer.ToInt32(), Is.EqualTo(firstMessage));

                    // Sending second message to receive...
                    var send2 = server.SendDataAsync(new ArraySegment<byte>(Encoding.ASCII.GetBytes(secondMessage)));
                    var result = new MemoryStream();
                    await transport.ReadBytesAsync(buffer, secondMessage.Length, _ => { result.Write(buffer, 0, _); }, CancellationToken.None);
                    await send2;
                    Assert.That(Encoding.ASCII.GetString(result.ToArray(), 0, (int)result.Position), Is.EqualTo(secondMessage));
                }
            }
        }

        [Test]
        public async Task ReadShouldThrowServerDisconnectedExceptionWhenDisconnected()
        {
            var disconnectedCount = 0;
            var endpoint = TestConfig.ServerEndpoint();
            using (var server = CreateServer(endpoint.Ip.Port, TestConfig.Log)) {
                server.OnDisconnected = () => Interlocked.Increment(ref disconnectedCount);
                using (var transport = CreateTransport(endpoint, TestConfig.Options.ConnectionConfiguration, TestConfig.Log)) {
                    await transport.ConnectAsync(CancellationToken.None);
                    var buffer = new byte[48];
                    var taskResult = transport.ReadBytesAsync(buffer, 4, _ => { }, CancellationToken.None);

                    //wait till connected
                    await Task.WhenAny(server.ClientConnected, Task.Delay(TimeSpan.FromSeconds(3)));

                    server.DropConnection();

                    await TaskTest.WaitFor(() => disconnectedCount > 0);

                    await Task.WhenAny(taskResult, Task.Delay(1000)).ConfigureAwait(false);

                    Assert.That(taskResult.IsFaulted, Is.True);
                    Assert.That(taskResult.Exception.InnerException, Is.TypeOf<ConnectionException>());
                }
            }
        }

        [Test]
        public async Task WhenNoConnectionThrowSocketExceptionAfterMaxRetry()
        {
            var connectionAttempts = 0;
            const int maxRetries = 2;
            var endpoint = TestConfig.ServerEndpoint();
            var config = new ConnectionConfiguration(
                Retry.AtMost(maxRetries),
                onConnecting: (e, attempt, elapsed) => Interlocked.Increment(ref connectionAttempts)
                );
            using (var transport = CreateTransport(endpoint, config, TestConfig.Log)) {
                try {
                    await transport.ConnectAsync(CancellationToken.None);
                    Assert.Fail("Did not throw ConnectionException");
                } catch (ConnectionException) {
                    // expected
                }
                Assert.That(connectionAttempts, Is.EqualTo(1 + maxRetries));
            }
        }

        [Test]
        public async Task ReadShouldStackReadRequestsAndReturnOneAtATime()
        {
            var endpoint = TestConfig.ServerEndpoint();
            using (var server = CreateServer(endpoint.Ip.Port, TestConfig.Log))
            {
                var messages = new[] { "test1", "test2", "test3", "test4" };
                var expectedLength = "test1".Length;

                var payload = new KafkaWriter().Write(messages);

                using (var transport = CreateTransport(endpoint, TestConfig.Options.ConnectionConfiguration, TestConfig.Log)) {
                    await transport.ConnectAsync(CancellationToken.None);
                    var tasks = messages.Select(
                        x => {
                            var b = new byte[x.Length];
                            return transport.ReadBytesAsync(b, b.Length, _ => { }, CancellationToken.None);
                        }).ToArray();

                    var send = server.SendDataAsync(payload.ToSegment());

                    await Task.WhenAll(tasks);

                    foreach (var task in tasks) {
                        Assert.That(task.Result, Is.EqualTo(expectedLength));
                    }
                }
            }
        }

        #endregion

        #region WriteBytes

        [Test]
        public async Task WriteAsyncShouldSendData()
        {
            var endpoint = TestConfig.ServerEndpoint();
            using (var server = CreateServer(endpoint.Ip.Port, TestConfig.Log))
            using (var transport = CreateTransport(endpoint, TestConfig.Options.ConnectionConfiguration, TestConfig.Log))
            {
                const int testData = 99;
                int result = 0;

#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously
                server.OnReceivedAsync = async data => result = data.ToInt32();
#pragma warning restore CS1998 // Async method lacks 'await' operators and will run synchronously

                await transport.ConnectAsync(CancellationToken.None);
                await transport.WriteBytesAsync(5, new ArraySegment<byte>(testData.ToBytes()), CancellationToken.None);
                await TaskTest.WaitFor(() => result > 0);
                Assert.That(result, Is.EqualTo(testData));
            }
        }

        [Test]
        public async Task WriteAsyncShouldAllowMoreThanOneWrite()
        {
            var endpoint = TestConfig.ServerEndpoint();
            using (var server = CreateServer(endpoint.Ip.Port, TestConfig.Log))
            using (var transport = CreateTransport(endpoint, TestConfig.Options.ConnectionConfiguration, TestConfig.Log))
            {
                const int testData = 99;
                var results = new List<byte>();

#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously
                server.OnReceivedAsync = async data => results.AddRange(data.Array.Skip(data.Offset).Take(data.Count));
#pragma warning restore CS1998 // Async method lacks 'await' operators and will run synchronously

                await transport.ConnectAsync(CancellationToken.None);
                await Task.WhenAll(
                    transport.WriteBytesAsync(5, new ArraySegment<byte>(testData.ToBytes()), CancellationToken.None), 
                    transport.WriteBytesAsync(6, new ArraySegment<byte>(testData.ToBytes()), CancellationToken.None));
                await TaskTest.WaitFor(() => results.Count >= 8);
                Assert.That(results.Count, Is.EqualTo(8));
            }
        }

        [Test]
        public async Task AsynchronousWriteAndReadShouldBeConsistent()
        {
            const int requests = 10;
            var expected = requests.Repeat(i => i).ToList();
            var readOnServer = new ConcurrentBag<int>();
            var readOnClient = new ConcurrentBag<int>();

            var endpoint = TestConfig.ServerEndpoint();
            using (var server = CreateServer(endpoint.Ip.Port, TestConfig.Log)) {
                using (var transport = CreateTransport(endpoint, TestConfig.Options.ConnectionConfiguration, TestConfig.Log)) {
#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously
                    server.OnReceivedAsync = async data => {
                        var d = data.Batch(4).Select(x => x.ToArray().ToInt32());
                        foreach (var item in d) {
                            readOnServer.Add(item);
                        }
                    };
#pragma warning restore CS1998 // Async method lacks 'await' operators and will run synchronously
                    await transport.ConnectAsync(CancellationToken.None);

                    var clientWriteTasks = expected.Select(i => transport.WriteBytesAsync(i, new ArraySegment<byte>(i.ToBytes()), CancellationToken.None));
                    var clientReadTasks = expected.Select(
                        i => {
                            var b = new byte[4];
                            return transport.ReadBytesAsync(b, b.Length, _ => { }, CancellationToken.None)
                                            .ContinueWith(t => readOnClient.Add(b.ToInt32()));
                        });
                    var serverWriteTasks = expected.Select(i => server.SendDataAsync(new ArraySegment<byte>(i.ToBytes())));

                    await Task.WhenAll(clientWriteTasks.Union(clientReadTasks).Union(serverWriteTasks));
                    await TaskTest.WaitFor(() => readOnServer.Count == requests);
                    Assert.That(readOnServer.Count, Is.EqualTo(requests), "not all writes propagated to the server in time");
                    await TaskTest.WaitFor(() => readOnClient.Count == requests);
                    Assert.That(readOnClient.Count, Is.EqualTo(requests), "not all reads happend on the client in time");
                    var w = readOnServer.OrderBy(x => x);
                    var r = readOnClient.OrderBy(x => x);

                    for (var i = 0; i < requests; i++) {
                        Assert.That(w.ElementAt(i), Is.EqualTo(expected[i]));
                    }
                    for (var i = 0; i < requests; i++) {
                        Assert.That(r.ElementAt(i), Is.EqualTo(expected[i]));
                    }
                }
            }
        }

        [Test]
        public async Task WriteShouldHandleLargeVolumeSendAsynchronously([Values(1000, 5000)] int requests)
        {
            var readOnServer = new ConcurrentBag<int>();
            var endpoint = TestConfig.ServerEndpoint();
            using (var server = CreateServer(endpoint.Ip.Port, TestConfig.Log)) {
                using (var transport = CreateTransport(endpoint, TestConfig.Options.ConnectionConfiguration, TestConfig.Log)) {
#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously
                    server.OnReceivedAsync = async data =>
                    {
                        var d = data.Batch(4).Select(x => x.ToArray().ToInt32());
                        foreach (var item in d) {
                            readOnServer.Add(item);
                        }
                    };
#pragma warning restore CS1998 // Async method lacks 'await' operators and will run synchronously

                    await transport.ConnectAsync(CancellationToken.None);
                    var clientWriteTasks = Enumerable.Range(1, requests).Select(i => transport.WriteBytesAsync(i, new ArraySegment<byte>(i.ToBytes()), CancellationToken.None));

                    await Task.WhenAll(clientWriteTasks);
                    await TaskTest.WaitFor(() => readOnServer.Count == requests);
                    Assert.That(readOnServer.Count, Is.EqualTo(requests), "not all writes propagated to the server in time");
                    Assert.That(readOnServer.OrderBy(x => x), Is.EqualTo(Enumerable.Range(1, requests)));
                }
            }
        }

        [Test]
        public async Task WriteShouldCancelWhileSendingData()
        {
            var clientWriteAttempts = 0;
            var config = new ConnectionConfiguration(onWritingBytes: (e, payload) => Interlocked.Increment(ref clientWriteAttempts));
            var endpoint = TestConfig.ServerEndpoint();
            using (var server = CreateServer(endpoint.Ip.Port, TestConfig.Log)) {
                using (var transport = CreateTransport(endpoint, config, TestConfig.Log)) {
                    using (var token = new CancellationTokenSource())
                    {
                        await transport.ConnectAsync(token.Token);
                        var write = transport.WriteBytesAsync(5, new ArraySegment<byte>(1.ToBytes()), token.Token);

                        await Task.WhenAny(server.ClientConnected, Task.Delay(TimeSpan.FromSeconds(3)));
                        await TaskTest.WaitFor(() => clientWriteAttempts > 0);

                        Assert.That(clientWriteAttempts, Is.EqualTo(1), "Socket should have attempted to write.");

                        //create a buffer write that will take a long time
                        var data = Enumerable.Range(0, 100000000).Select(b => (byte)b).ToArray();
                        token.Cancel();
                        var taskResult = transport.WriteBytesAsync(6, new ArraySegment<byte>(data), token.Token);
                        await Task.WhenAny(taskResult, Task.Delay(TimeSpan.FromSeconds(5))).ConfigureAwait(false);

                        Assert.That(taskResult.IsCanceled || !taskResult.IsFaulted, Is.True, "Task should have cancelled.");
                    }
                }
            }
        }

        #endregion
    }
}